# Mern_2ndexam
Q1.(ans)- ARP stands for Address Resolution Protocol, which is used to find the MAC address of the device from its known IP address. This means, the source device already knows the IP address but not the MAC address of the destination device. The MAC address of the device is required because you cannot communicate with a device in a local area network (Ethernet) without knowing its MAC address. So, the Address Resolution Protocol helps to obtain the MAC address of the destination device.
=============================================================================================================================================================================================
Q2.(ans)- Network Address Translation (NAT) is a service that enables private IP networks to use the internet and cloud. NAT translates private IP addresses in an internal network to a public IP address before packets are sent to an external network.
=============================================================================================================================================================================================
Q3.(ans)- A private IP address is a range of non-internet facing IP addresses used in an internal network. Private IP addresses are provided by network devices, such as routers, using network address translation.
=============================================================================================================================================================================================
Q4.(ana)- There are four different conditions that result in Deadlock. These four conditions are also known as Coffman conditions and these conditions are not mutually exclusive. Let's look at them one by one.
<1> Mutual Exclusion: A resource can be held by only one process at a time. In other words, if a process P1 is using some resource R at a particular instant of time, then some other process P2 can't hold or use the same resource R at that particular instant of time. The process P2 can make a request for that resource R but it can't use that resource simultaneously with process P1.
<2> Hold and Wait: A process can hold a number of resources at a time and at the same time, it can request for other resources that are being held by some other process. For example, a process P1 can hold two resources R1 and R2 and at the same time, it can request some resource R3 that is currently held by process P2.
<3> No preemption: A resource can't be preempted from the process by another process, forcefully. For example, if a process P1 is using some resource R, then some other process P2 can't forcefully take that resource. If it is so, then what's the need for various scheduling algorithm. The process P2 can request for the resource R and can wait for that resource to be freed by the process P1.
<4> Circular Wait: Circular wait is a condition when the first process is waiting for the resource held by the second process, the second process is waiting for the resource held by the third process, and so on. At last, the last process is waiting for the resource held by the first process. So, every process is waiting for each other to release the resource and no one is releasing their own resource. Everyone is waiting here for getting the resource. This is called a circular wait.
=============================================================================================================================================================================================
Q5.(ans)-Swap memory is basically parts/pages of memory from the RAM (your high-speed primary memory) which is switching to use a file (or partition) dedicated on the harddrive as memory space instead. So if the physical memory is full, you can use swap space for extra memory resources. It is useful if you have low memory on your machine, and if you do not want your machine to run out of memory in eg. high traffic environments.
=============================================================================================================================================================================================
Q6.(ans)-
=============================================================================================================================================================================================
Q7.(ans)- Consistent hashing is a simple yet powerful strategy for divvying up data between multiple machines. This algorithm is particularly useful for systems with large distributed databases with many machines powering high-traffic applications and dynamic websites.
=============================================================================================================================================================================================
Q8.(ans)-  When you type something like “www.attainu.com” into your browser, many different things happen, and many more could happen depending on things like whether you’re at home or at work. In this article to give a good overview of the process, we’re going to go through a common path to get from typing in a url like “google.com” on your home computer to getting the google search page, assuming every service is up and working correctly.

*The first DNS request for “www.attainu.com”

As soon as you hit enter, your browser will try to resolve the hostname into an IP address. To do this, your computer makes a DNS request for “attainu.com”. This request is sent to the ip address of the domain servers configured on your computer. For example purposes, lets say we use one of Google’s name servers, 8.8.8.8. The request is sent out to 8.8.8.8 on UDP port 53 (the default DNS port). The UDP header includes information about where to send return packets, such as an IP address which for your home computer we’ll call 192.168.0.5. You have a router at home that probably has some kind of internal firewall for routing these packets. That firewall checks if you’re allowed to send the packets, and generally outbound traffic is not filtered on home routers.

After that you have to deal with Network Address Translation (NAT). Since there are multiple computers on your home network with their own private (internal to your home network), but only one public ip address (the one that the internet sees), if all the home network computers request a DNS response that is returned to port 53, the router won’t know which computer to send it to. So instead, these client requests are mapped to quasi-random high numbered ports for each computer. The router will rewrite the packet header with the public ip and the mapped port (lets say it is 147.47.47.47 port 10000), listen for a response on those ports, and when it gets one will forward that packed back to the computer that originally requested the packet that cause the router to listen on that port.

So now we’re out into the greater public internet. At this point your traffic passes through a number of switches designed to make sure your traffic goes through the right physical cables to get to the datacenter associated with the IP address 8.8.8.8. Once it arrives at the datacenter, there will be a few more routers and switches before you finally arrive at the firewall before the server. If your DNS server ip is good, the firewall at the destination will be configured to allow inbound traffic on the DNS port. There may be some forwarding rules in the firewall, but this is not required and for simplicitly we will assume there are none. This is then forwarded into the server at 8.8.8.8.

Chances are the server you arrive at is actually a load balancer connected to many other internal servers which process the request. The load balancer will see that you’re requesting something on the DNS port and will find an available DNS server to send your request to. That DNS server will receive your request, look up the name “google.com” and send the results back. Lets say it is at ip address 157.57.57.57. The reverse process happens going back to your home computer, except the IP address and port it is sent to is 147.47.47.47 port 10000. This arrives at your home router, which then looks at its port mapping table, finds the mapping for your home computer, rewrites the packet header with the address information for your home computer’s private IP address (such as 192.168.0.5 port 53 in our example) then sends the packet.

*The first connection to attainu.com via http

So now we have the ip address for “google.com” and we can try to connect to it. This time we’re going to use TCP/IP instead of UDP. UDP is useful when packetloss or resending is not a big issue since it is faster due to less checking. But, if you need every packet then you want to use TCP/IP, which for a website we do because even a few missing or incorrect bytes could break code syntax and potentially the entire site! The solution there would be to redownload the site, which for a large website could take some time. DNS request are generally much smaller.

So we’re going to send a request to 157.57.57.57 port 80 (the default http port). NAT, routing, firewalling and public switching occurs as in the previous DNS lookup, and we arrive at 157.57.57.57. Likely this is a load balancer as well, especially with a company serving as much traffic as google. By the port you sent the packet to, it will see that you’re requesting an http transaction then find an available webserver to forward your request to. Upon arriving at this webserver, we need to perform the TCP 3-way handshake.

The initial packet is sent from your home computer with a TCP SYN (for SYNchronize) header bit, for synchronize. Upon receiving the SYN message from your home computer, the receiving webserver needs to send back a SYN-ACK (SYNchronize-ACKnowledge). Upon receiving this message, your home computer needs to send back a final ACK. Upon receiving this final ACK, a “socket” is created. This socket is used to transfer data in a reliable and more secure, if slower than UDP, fashion.

Most websites are moving towards using https only so web traffic is encrypted, and google.com is no execption. The webserver will return a 301 http code for permanently redirected, and a website to go to of “https://www.attainu.com”. When this information returns to your browser, it will terminate the socket Your computer sends a FIN packet first. Then the server sends an ACK, closes its side of services it needs to then sends a FIN. Finally, your computer sends an ACK and then the socket is closed. After this, your browser will attempt to go to “https://www.attainu.com”.

*Going to “https://www.attainu.com”

The first thing that happens is a new DNS request like the previous one, but for “www.attainu.com”. The https:// is just specifying a protocol for the message format for the browser, and is not part of the hostname, which is what is used to find the destination server. Chances are, this will be the same address as before, 157.57.57.57. Now we need to connect to it again with TCP/IP, but this time on the port for https, 443. This happens the same as with http up to after the TCP 3-way handshake.

After the TCP handshake, it is time for the SSL handshake. Your computer sends an ClientHello, containing the various SSL/TLS versions and other cryptographic options it supports. The server will respond with a similar ServerHello that also includes a decision on what encryption method to use. After that the server needs to prove its identity, and sends over its SSL certificate so your computer can verify it. Your computer will check the signing certificate authority (CA) of that certificate against its trusted certificates, and if it can match that, then your computer’s browser will check with the presumably signing certificate authority to make sure that it is actually certified by the certificate authority.

After that, one way encryption is set up from the server to your home computer. The server generates a session encryption key and sends this to your computer. This key is used to create 2-way encryption so you can send encrypted information back to the server. After that the contents of every TCP/IP packet are encrypted using this key, and otherwise proceeds as a normal http operation. In this case, the html data will be streamed back, encrypted at the server and decrypted at your computer, so your page will display Google’s search page.

============================================================================================================================================================================================
Q9.(ans)- Context Switching involves storing the context or state of a process so that it can be reloaded when required and execution can be resumed from the same point as earlier. This is a feature of a multitasking operating system and allows a single CPU to be shared by multiple processes.
============================================================================================================================================================================================
Q10.(ans)- TCP/IP was designed and developed by the Department of Defense (DoD) in the 1960s and is based on standard protocols. It stands for Transmission Control Protocol/Internet Protocol. The TCP/IP model is a concise version of the OSI model. It contains four layers, unlike the seven layers in the OSI model.

The number of layers is sometimes referred to as five or four. Here In this article, we’ll study five layers. The Physical Layer and Data Link Layer are referred to as one single layer as the ‘Physical Layer’ or ‘Network Interface Layer’ in the 4-layer reference-
1. Application Layer
2.Transport Layer(TCP/UDP)
3.Network/Internet Layer(IP)
4.Data Link Layer (MAC)
5.Physical Layer
------------------------
1. Application Layer- This layer is analogous to the transport layer of the OSI model. It is responsible for end-to-end communication and error-free delivery of data. It shields the upper-layer applications from the complexities of data. The three main protocols present in this layer are:

<i> HTTP and HTTPS: HTTP stands for Hypertext transfer protocol. It is used by the World Wide Web to manage communications between web browsers and servers. HTTPS stands for HTTP-Secure. It is a combination of HTTP with SSL(Secure Socket Layer). It is efficient in cases where the browser needs to fill out forms, sign in, authenticate, and carry out bank transactions.
<ii> SSH: SSH stands for Secure Shell. It is a terminal emulations software similar to Telnet. The reason SSH is preferred is because of its ability to maintain the encrypted connection. It sets up a secure session over a TCP/IP connection.
<iii> NTP: NTP stands for Network Time Protocol. It is used to synchronize the clocks on our computer to one standard time source. It is very useful in situations like bank transactions. Assume the following situation without the presence of NTP. Suppose you carry out a transaction, where your computer reads the time at 2:30 PM while the server records it at 2:28 PM. The server can crash very badly if it’s out of sync.
----------------------------------------------
2. Transport Layer- The TCP/IP transport layer protocols exchange data receipt acknowledgments and retransmit missing packets to ensure that packets arrive in order and without error. End-to-end communication is referred to as such. Transmission Control Protocol (TCP) and User Datagram Protocol are transport layer protocols at this level (UDP).

<i> TCP: Applications can interact with one another using TCP as though they were physically connected by a circuit. TCP transmits data in a way that resembles character-by-character transmission rather than separate packets. A starting point that establishes the connection, the whole transmission in byte order, and an ending point that closes the connection make up this transmission.
<ii> UDP: The datagram delivery service is provided by UDP, the other transport layer protocol. Connections between receiving and sending hosts are not verified by UDP. Applications that transport little amounts of data use UDP rather than TCP because it eliminates the processes of establishing and validating connections.
----------------------------------------------------------------------------------------------------------------------------------------
3. Network Layer- This layer parallels the functions of OSI’s Network layer. It defines the protocols which are responsible for the logical transmission of data over the entire network. The main protocols residing at this layer are as follows:

<i> IP: IP stands for Internet Protocol and it is responsible for delivering packets from the source host to the destination host by looking at the IP addresses in the packet headers. IP has 2 versions: IPv4 and IPv6. IPv4 is the one that most websites are using currently. But IPv6 is growing as the number of IPv4 addresses is limited in number when compared to the number of users.
<ii>ICMP: ICMP stands for Internet Control Message Protocol. It is encapsulated within IP datagrams and is responsible for providing hosts with information about network problems.
ARP: ARP stands for Address Resolution Protocol. Its job is to find the hardware address of a host from a known IP address. ARP has several types: Reverse ARP, Proxy ARP, Gratuitous ARP, and Inverse ARP.
----------------
4.Data Link Layer- The packet’s network protocol type, in this case, TCP/IP, is identified by the data-link layer. Error prevention and “framing” are also provided by the data-link layer. Point-to-Point Protocol (PPP) framing and Ethernet IEEE 802.2 framing are two examples of data-link layer protocols.
-------------------------------------------------------------------------------------------------------------------
5.Physical Layer-It is a group of applications requiring network communications. This layer is responsible for generating the data and requesting connections. It acts on behalf of the sender and the Network Access layer on the behalf of the receiver. During this article, we will be talking on the behalf of the receiver.
=============================================================================================================================================================================================
